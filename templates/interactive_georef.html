
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive IFC Georeferencing</title>
    <link rel="icon" type="image/x-icon" >
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Inter', 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, #F3F3F3 0%, #e8e8e8 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background-color: white;
            border-radius: 16px;
            box-shadow: 0px 1px 6px 0px rgba(0, 0, 0, 0.12);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #B0C70D 0%, #8fa30a 100%);
            color: white;
            padding: 32px 24px;
            text-align: center;
            position: relative;
            overflow: hidden;
        }
        
        .header::before {
            content: '';
            position: absolute;
            top: -50%;
            right: -10%;
            width: 400px;
            height: 400px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 50%;
        }
        
        .header h1 {
            font-size: 32px;
            font-weight: 700;
            margin-bottom: 8px;
            position: relative;
            z-index: 1;
        }
        
        .header p {
            font-size: 16px;
            opacity: 0.95;
            position: relative;
            z-index: 1;
        }
        
        .step-indicator {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 24px;
            background: #FCFFE7;
            gap: 16px;
        }
        
        .step {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .step-number {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: #D1D5DB;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 16px;
            transition: all 0.3s ease;
        }
        
        .step.active .step-number {
            background: linear-gradient(135deg, #B0C70D 0%, #8fa30a 100%);
            box-shadow: 0 4px 12px rgba(176, 199, 13, 0.3);
            transform: scale(1.1);
        }
        
        .step.completed .step-number {
            background-color: #B0C70D;
        }
        
        .step-divider {
            width: 60px;
            height: 2px;
            background-color: #D1D5DB;
        }
        
        .main-content {
            display: flex;
            min-height: 70vh;
        }
        
        @media (max-width: 968px) {
            .main-content {
                flex-direction: column;
            }
            
            .left-panel, .right-panel {
                width: 100% !important;
                border-right: none !important;
                border-bottom: 2px solid #F3F3F3;
            }
        }
        
        .left-panel {
            width: 50%;
            border-right: 2px solid #F3F3F3;
            display: flex;
            flex-direction: column;
        }
        
        .right-panel {
            width: 50%;
            display: flex;
            flex-direction: column;
        }
        
        .panel-header {
            background: linear-gradient(to right, #FCFFE7, #f8fce0);
            padding: 20px 24px;
            border-bottom: 2px solid #F3F3F3;
            font-weight: 600;
            font-size: 16px;
            color: #111827;
        }
        
        .panel-content {
            flex: 1;
            padding: 24px;
            overflow: auto;
        }
        
        .viewer-container {
            width: 100%;
            min-height: 500px;
            height: 500px;
            border: 2px solid #F3F3F3;
            border-radius: 12px;
            background: linear-gradient(135deg, #FCFFE7 0%, #f8fce0 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            transition: all 0.3s ease;
            overflow: hidden;
        }
        
        .viewer-container canvas {
            width: 100% !important;
            height: 100% !important;
            display: block;
            cursor: grab;
        }
        
        .viewer-container canvas:active {
            cursor: grabbing;
        }
        
        .viewer-container:hover {
            border-color: #B0C70D;
            box-shadow: 0 4px 16px rgba(176, 199, 13, 0.15);
        }
        
        .map-container {
            width: 100%;
            height: 100%;
            min-height: 400px;
            border: 2px solid #F3F3F3;
            border-radius: 12px;
            overflow: hidden;
        }
        
        .controls {
            background-color: #F3F3F3;
            padding: 20px 24px;
            border-top: 2px solid #EEEEEE;
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            align-items: center;
        }
        
        .btn {
            background: linear-gradient(135deg, #B0C70D 0%, #8fa30a 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            font-size: 14px;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(176, 199, 13, 0.2);
        }
        
        .btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(176, 199, 13, 0.3);
        }
        
        .btn:active:not(:disabled) {
            transform: translateY(0);
        }
        
        .btn:disabled {
            background: linear-gradient(135deg, #D1D5DB 0%, #b8bcc0 100%);
            cursor: not-allowed;
            box-shadow: none;
        }
        
        .btn-success {
            background: linear-gradient(135deg, #B0C70D 0%, #9ab50b 100%);
        }
        
        .btn-danger {
            background: linear-gradient(135deg, #ee5253 0%, #d63e3f 100%);
        }
        
        .btn-danger:hover:not(:disabled) {
            box-shadow: 0 4px 12px rgba(238, 82, 83, 0.3);
        }
        
        .coordinates-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 24px;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
        }
        
        .coordinates-table th,
        .coordinates-table td {
            border: 1px solid #F3F3F3;
            padding: 12px 16px;
            text-align: center;
        }
        
        .coordinates-table th {
            background: linear-gradient(to right, #B0C70D, #9ab50b);
            color: white;
            font-weight: 600;
            font-size: 14px;
        }
        
        .coordinates-table tbody tr {
            transition: background-color 0.2s ease;
        }
        
        .coordinates-table tbody tr:nth-child(even) {
            background-color: #FCFFE7;
        }
        
        .coordinates-table tbody tr:hover {
            background-color: #f0f8e0;
        }
        
        .coord-input {
            width: 100%;
            padding: 8px;
            border: 2px solid #D1D5DB;
            border-radius: 6px;
            font-size: 14px;
            text-align: center;
            transition: all 0.3s ease;
        }
        
        .coord-input:focus {
            outline: none;
            border-color: #B0C70D;
            background-color: #FCFFE7;
        }
        
        .coord-input:hover {
            border-color: #B0C70D;
        }
        
        .latlng-display {
            font-size: 13px;
            color: #6B7280;
        }
        
        .point-marker {
            position: absolute;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            border: 3px solid white;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            transform: translate(-50%, -50%);
            z-index: 1000;
            animation: markerPop 0.3s ease;
        }
        
        @keyframes markerPop {
            0% { transform: translate(-50%, -50%) scale(0); }
            50% { transform: translate(-50%, -50%) scale(1.2); }
            100% { transform: translate(-50%, -50%) scale(1); }
        }
        
        .building-point {
            background-color: #ee5253;
        }
        
        .map-point {
            background-color: #B0C70D;
        }
        
        .instruction {
            background-color: #FCFFE7;
            border: 2px solid #B0C70D;
            border-radius: 12px;
            padding: 16px 20px;
            margin-bottom: 20px;
            color: #374151;
            line-height: 1.6;
        }
        
        .error {
            background-color: #fee;
            border: 2px solid #ee5253;
            border-radius: 12px;
            padding: 16px 20px;
            margin-bottom: 20px;
            color: #c82333;
        }
        
        input[type="file"] {
            padding: 10px 16px;
            border: 2px solid #D1D5DB;
            border-radius: 8px;
            font-size: 14px;
            transition: all 0.3s ease;
            background: white;
        }
        
        input[type="file"]:hover {
            border-color: #B0C70D;
        }
        
        select {
            padding: 10px 16px;
            border: 2px solid #D1D5DB;
            border-radius: 8px;
            font-size: 14px;
            background: white;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        select:hover, select:focus {
            border-color: #B0C70D;
            outline: none;
        }
        
        label {
            font-weight: 600;
            color: #374151;
            font-size: 14px;
        }
        
        #upload-status {
            font-size: 13px;
            color: #6B7280;
            margin-top: 8px;
        }
        
        #final-config {
            background: linear-gradient(135deg, #FCFFE7 0%, #f8fce0 100%);
            padding: 24px;
            border-radius: 12px;
            margin-top: 24px;
            border: 2px solid #B0C70D;
        }
        
        #final-config h3 {
            color: #111827;
            margin-bottom: 16px;
            font-size: 20px;
        }
        
        pre {
            background: white;
            padding: 16px;
            border-radius: 8px;
            overflow-x: auto;
            font-size: 13px;
            border: 1px solid #D1D5DB;
            margin: 12px 0;
        }
        
        .bottom-controls {
            text-align: center;
            padding: 24px;
            border-top: 2px solid #F3F3F3;
            background: white;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Interactive IFC Georeferencing</h1>
            <p>Click points on your building model and map them to geographic coordinates</p>
        </div>
        
        <div class="step-indicator">
            <div class="step active" id="step-1">
                <div class="step-number" id="step1">1</div>
            </div>
            <div class="step-divider"></div>
            <div class="step" id="step-2">
                <div class="step-number" id="step2">2</div>
            </div>
            <div class="step-divider"></div>
            <div class="step" id="step-3">
                <div class="step-number" id="step3">3</div>
            </div>
        </div>
        
        <div class="main-content">
            <div class="left-panel">
                <div class="panel-header">
                    <span id="left-title">Step 1: Select Points on Building</span>
                </div>
                <div class="panel-content">
                    <div class="instruction" id="instruction">
                        First, upload your IFC file, then select exactly 3 control points. You can either:
                        <br>• <strong>Double-click</strong> on the 3D building model to add points (coordinates will populate in the table below), OR
                        <br>• <strong>Enter X, Y, Z values</strong> manually in the table
                        <br><br>
                        <strong>3D Viewer Controls:</strong>
                        <br>• <strong>Left mouse drag:</strong> Rotate view
                        <br>• <strong>Right mouse drag:</strong> Pan view
                        <br>• <strong>Mouse wheel:</strong> Zoom in/out
                        <br>• <strong>Double-click on building:</strong> Select control point
                    </div>
                    
                    <div style="margin-bottom: 15px;">
                        <input type="file" id="file-upload" accept=".ifc" style="margin-bottom: 10px;">
                        <div id="upload-status"></div>
                    </div>
                    
                    <div class="viewer-container" id="building-viewer">
                        <div id="viewer-placeholder" style="text-align: center; color: #6c757d;">
                            <p style="font-weight: 600; margin-bottom: 8px;">IFC Model Viewer</p>
                            <p>Please upload an IFC file and click Load Model</p>
                        </div>
                    </div>
                </div>
                <div class="controls">
                    <button class="btn" id="load-model" onclick="loadBuildingModel()">Load Model</button>
                    <button class="btn btn-danger" onclick="clearBuildingPoints()" disabled id="clear-building">Clear Points</button>
                </div>
            </div>
            
            <div class="right-panel">
                <div class="panel-header">
                    <span id="right-title">Step 2: Select Geographic Coordinates</span>
                </div>
                <div class="panel-content">
                    <div class="instruction" id="map-instruction" style="display: none;">
                        Set geographic coordinates for each building point. You can either:
                        <br>• <strong>Click on the map</strong> to add points (coordinates will populate in the table below), OR
                        <br>• <strong>Enter Easting, Northing, Elevation</strong> manually in the table (map markers will appear automatically)
                    </div>
                    
                    <!-- Manual coordinate entry -->
                    <div id="manual-entry" style="display: none; background: #FCFFE7; padding: 16px; border-radius: 8px; margin-bottom: 16px; border: 2px solid #B0C70D;">
                        <h4 style="margin: 0 0 12px 0; color: #111827; font-size: 14px;">Add Point Manually (Point <span id="current-point-number">1</span>/3)</h4>
                        <div style="display: flex; gap: 12px; flex-wrap: wrap; align-items: end;">
                            <div style="flex: 1; min-width: 120px;">
                                <label for="manual-lat" style="display: block; margin-bottom: 4px;">Latitude (°N):</label>
                                <input type="number" id="manual-lat" step="0.000001" placeholder="e.g., 47.3769" 
                                       style="width: 100%; padding: 8px; border: 2px solid #D1D5DB; border-radius: 6px;">
                            </div>
                            <div style="flex: 1; min-width: 120px;">
                                <label for="manual-lng" style="display: block; margin-bottom: 4px;">Longitude (°E):</label>
                                <input type="number" id="manual-lng" step="0.000001" placeholder="e.g., 8.5417" 
                                       style="width: 100%; padding: 8px; border: 2px solid #D1D5DB; border-radius: 6px;">
                            </div>
                            <button class="btn" onclick="addManualPoint()" style="padding: 8px 16px;">Add Point</button>
                        </div>
                    </div>
                    
                    <div class="map-container" id="map-container">
                        <div id="map" style="width: 100%; height: 100%;"></div>
                    </div>
                </div>
                <div class="controls">
                    <label for="epsg-select">Coordinate System:</label>
                    <select id="epsg-select">
                        <option value="2056" selected>EPSG:2056 (CH1903+ / LV95 - Switzerland)</option>
                    </select>
                    <!-- <button class="btn" onclick="testTransformation()" style="background: #666;">Test Transform</button> -->
                    <button class="btn btn-danger" onclick="clearMapPoints()" disabled id="clear-map">Clear Map Points</button>
                </div>
            </div>
        </div>
        
        <div class="bottom-controls">
            <table class="coordinates-table" id="coordinates-table">
                <thead>
                    <tr>
                        <th rowspan="2">Point</th>
                        <th colspan="3">
                            <div style="display: flex; align-items: center; justify-content: center; gap: 8px; flex-wrap: wrap;">
                                <span>Building Coordinates</span>
                                <select id="building-unit" onchange="convertBuildingUnits()" style="font-size: 12px; padding: 2px;">
                                    <option value="mm">mm</option>
                                    <option value="m">meters</option>
                                    <option value="in">inches</option>
                                    <option value="ft">feet</option>
                                </select>
                            </div>
                        </th>
                        <th colspan="3">Geographic Coordinates</th>
                        <th rowspan="2">Lat/Lon</th>
                    </tr>
                    <tr>
                        <th>X</th>
                        <th>Y</th>
                        <th>Z</th>
                        <th>Easting</th>
                        <th>Northing</th>
                        <th>Elevation</th>
                    </tr>
                </thead>
                <tbody id="coordinates-body">
                    <tr>
                        <td>P1</td>
                        <td><input type="number" step="any" class="coord-input building-coord" data-point="0" data-axis="x" placeholder="X"></td>
                        <td><input type="number" step="any" class="coord-input building-coord" data-point="0" data-axis="y" placeholder="Y"></td>
                        <td><input type="number" step="any" class="coord-input building-coord" data-point="0" data-axis="z" placeholder="Z"></td>
                        <td><input type="number" step="any" class="coord-input map-coord" data-point="0" data-axis="easting" placeholder="Easting"></td>
                        <td><input type="number" step="any" class="coord-input map-coord" data-point="0" data-axis="northing" placeholder="Northing"></td>
                        <td><input type="number" step="any" class="coord-input map-coord" data-point="0" data-axis="elevation" placeholder="Elevation"></td>
                        <td class="latlng-display">-</td>
                    </tr>
                    <tr>
                        <td>P2</td>
                        <td><input type="number" step="any" class="coord-input building-coord" data-point="1" data-axis="x" placeholder="X"></td>
                        <td><input type="number" step="any" class="coord-input building-coord" data-point="1" data-axis="y" placeholder="Y"></td>
                        <td><input type="number" step="any" class="coord-input building-coord" data-point="1" data-axis="z" placeholder="Z"></td>
                        <td><input type="number" step="any" class="coord-input map-coord" data-point="1" data-axis="easting" placeholder="Easting"></td>
                        <td><input type="number" step="any" class="coord-input map-coord" data-point="1" data-axis="northing" placeholder="Northing"></td>
                        <td><input type="number" step="any" class="coord-input map-coord" data-point="1" data-axis="elevation" placeholder="Elevation"></td>
                        <td class="latlng-display">-</td>
                    </tr>
                    <tr>
                        <td>P3</td>
                        <td><input type="number" step="any" class="coord-input building-coord" data-point="2" data-axis="x" placeholder="X"></td>
                        <td><input type="number" step="any" class="coord-input building-coord" data-point="2" data-axis="y" placeholder="Y"></td>
                        <td><input type="number" step="any" class="coord-input building-coord" data-point="2" data-axis="z" placeholder="Z"></td>
                        <td><input type="number" step="any" class="coord-input map-coord" data-point="2" data-axis="easting" placeholder="Easting"></td>
                        <td><input type="number" step="any" class="coord-input map-coord" data-point="2" data-axis="northing" placeholder="Northing"></td>
                        <td><input type="number" step="any" class="coord-input map-coord" data-point="2" data-axis="elevation" placeholder="Elevation"></td>
                        <td class="latlng-display">-</td>
                    </tr>
                </tbody>
            </table>
            
            <div style="text-align: center; margin: 20px 0;">
                <button class="btn btn-success" onclick="generateConfig()" disabled id="generate-config-bottom" style="font-size: 16px; padding: 14px 32px;">
                    Generate Configuration
                </button>
            </div>
            
            <div id="final-config" style="display: none;">
                <h3>Configuration for Web Application:</h3>
                <div id="config-output"></div>
            </div>
        </div>
    </div>

    <!-- Include Leaflet for map -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    
    <!-- Include Proj4js for coordinate transformations -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.9.0/proj4.js"></script>
    
    <!-- Include Three.js for 3D model viewing -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    
    <script>
        // Global variables
        let buildingPoints = [];
        let mapPoints = [];
        let map = null;
        let currentStep = 1;
        let scene, camera, renderer, controls;
        let buildingModel = null;
        let ifcBounds = null;
        let ifcMeshes = [];  // Store all IFC meshes for raycasting
        let raycaster, mouse;  // Initialize later when THREE is loaded
        let is3DViewerInitialized = false;
        
        document.addEventListener('DOMContentLoaded', function() {
            // Check if proj4 is loaded
            if (typeof proj4 === 'undefined') {
                console.error('Proj4js library failed to load!');
            } else {
                console.log('Proj4js library loaded successfully');
            }
            
            initializeMap();
            setupEventListeners();
            initializeDefaultValues();
            
            const urlParams = new URLSearchParams(window.location.search);
            const filename = urlParams.get('filename');
            if (filename) {
                sessionStorage.setItem('selectedFilename', filename);
                loadBuildingModel(filename);
            }
            
            // Capture and store project_id and token from URL
            const projectId = urlParams.get('project_id');
            const token = urlParams.get('token');
            if (projectId) {
                sessionStorage.setItem('project_id', projectId);
            } else {
                const storedProjectId = sessionStorage.getItem('project_id');
            }
            
            if (token) {
                sessionStorage.setItem('auth_token', token);
            } else {
                const storedToken = sessionStorage.getItem('auth_token');
            }
        });
        
        function initializeDefaultValues() {
            // Initialize building points array with default Z values
            for (let i = 0; i < 3; i++) {
                const zInput = document.querySelector(`.building-coord[data-point="${i}"][data-axis="z"]`);
                const elevationInput = document.querySelector(`.map-coord[data-point="${i}"][data-axis="elevation"]`);
                
                if (zInput && zInput.value) {
                    // Trigger the input handler to store the default Z value in mm
                    const event = new Event('input');
                    Object.defineProperty(event, 'target', { value: zInput });
                    handleBuildingCoordInput(event);
                }
                
                if (elevationInput && elevationInput.value) {
                    // Trigger the input handler to store the default elevation value
                    const event = new Event('input');
                    Object.defineProperty(event, 'target', { value: elevationInput });
                    handleMapCoordInput(event);
                }
            }
        }
        
        function initializeMap() {
            map = L.map('map').setView([47.3769, 8.5417], 13);
            
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '© OpenStreetMap contributors'
            }).addTo(map);
            
            map.on('click', onMapClick);
        }
        
        function setupEventListeners() {
            // Don't add click listener here - we'll add it to the canvas after 3D viewer is initialized
            document.getElementById('file-upload').addEventListener('change', handleFileUpload);
            
            // Add event listeners for table inputs
            document.querySelectorAll('.building-coord').forEach(input => {
                input.addEventListener('input', handleBuildingCoordInput);
            });
            
            document.querySelectorAll('.map-coord').forEach(input => {
                input.addEventListener('input', handleMapCoordInput);
            });
        }
        
        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            if (!file.name.toLowerCase().endsWith('.ifc')) {
                alert('Please select an IFC file (.ifc extension)');
                return;
            }
            
            const statusDiv = document.getElementById('upload-status');
            statusDiv.innerHTML = 'Uploading file...';
            statusDiv.style.color = '#B0C70D';
            
            const formData = new FormData();
            formData.append('file', file);
            
            fetch('/upload', {
                method: 'POST',
                body: formData
            })
            .then(response => {
                if (response.redirected || response.ok) {
                    statusDiv.innerHTML = `File uploaded: ${file.name}`;
                    statusDiv.style.color = '#B0C70D';
                    
                    sessionStorage.setItem('selectedFilename', file.name);
                    loadBuildingModel(file.name);
                    
                    return;
                }
                throw new Error('Upload failed');
            })
            .catch(error => {
                statusDiv.innerHTML = 'Upload failed. Please try again.';
                statusDiv.style.color = '#ee5253';
                console.error('Upload error:', error);
            });
        }
        
        function loadBuildingModel() {
            const filename = getSelectedFilename();
            
            if (!filename) {
                alert('Please upload an IFC file first');
                return;
            }
            
            // Show loading message
            const viewer = document.getElementById('building-viewer');
            const placeholder = document.getElementById('viewer-placeholder');
            if (placeholder) {
                placeholder.innerHTML = '<p style="font-weight: 600;">Loading 3D Model...</p><p>Please wait...</p>';
            }
            
            // Load geometry from API
            fetch(`/api/ifc-geometry/${filename}`)
                .then(response => response.json())
                .then(data => {
                    if (data.error) {
                        throw new Error(data.error);
                    }
                    
                    ifcBounds = data.bounds;
                    
                    // Initialize 3D viewer
                    init3DViewer();
                    
                    // Load geometries into Three.js scene
                    data.geometries.forEach((geom, index) => {
                        const geometry = new THREE.BufferGeometry();
                        
                        const vertices = new Float32Array(geom.vertices);
                        const indices = new Uint32Array(geom.indices);
                        
                        geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
                        geometry.setIndex(new THREE.BufferAttribute(indices, 1));
                        geometry.computeVertexNormals();
                        
                        // Create material with color
                        const color = new THREE.Color(geom.color);
                        const material = new THREE.MeshPhongMaterial({
                            color: color,
                            side: THREE.DoubleSide,
                            flatShading: false
                        });
                        
                        const mesh = new THREE.Mesh(geometry, material);
                        mesh.userData.ifcType = geom.type;
                        scene.add(mesh);
                        ifcMeshes.push(mesh);
                    });
                    
                    // Position camera to view the entire model
                    const center = new THREE.Vector3(
                        data.bounds.center[0],
                        data.bounds.center[1],
                        data.bounds.center[2]
                    );
                    
                    const size = Math.max(...data.bounds.dimensions);
                    const distance = size * 2;
                    
                    camera.position.set(
                        center.x + distance,
                        center.y + distance,
                        center.z + distance
                    );
                    camera.lookAt(center);
                    
                    // Update controls target if available
                    if (controls && controls.target) {
                        controls.target.copy(center);
                        controls.update();
                    }
                    
                    // Remove placeholder
                    if (placeholder) {
                        placeholder.remove();
                    }
                    
                    // Enable controls
                    document.getElementById('clear-building').disabled = false;
                    
                    console.log(`Loaded ${data.geometries.length} geometries`);
                })
                .catch(error => {
                    console.error('Error loading IFC geometry:', error);
                    if (placeholder) {
                        placeholder.innerHTML = `<p style="color: #ee5253;">Error loading model: ${error.message}</p><p>Please try a different file</p>`;
                    }
                });
        }
        
        function init3DViewer() {
            // Check if THREE.js is loaded
            if (typeof THREE === 'undefined') {
                console.error('Three.js library not loaded!');
                alert('Error: 3D library not loaded. Please refresh the page.');
                return;
            }
            
            // Initialize raycaster and mouse vector
            if (!raycaster) {
                raycaster = new THREE.Raycaster();
                mouse = new THREE.Vector2();
            }
            
            if (is3DViewerInitialized) {
                // Clear existing scene
                while(scene.children.length > 0) { 
                    scene.remove(scene.children[0]); 
                }
                ifcMeshes = [];
                return;
            }
            
            const viewer = document.getElementById('building-viewer');
            
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f0f0);
            
            // Create camera
            const width = viewer.clientWidth;
            const height = viewer.clientHeight;
            camera = new THREE.PerspectiveCamera(60, width / height, 0.1, 100000);
            camera.position.set(50, 50, 50);
            
            // Create renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(width, height);
            renderer.setPixelRatio(window.devicePixelRatio);
            viewer.appendChild(renderer.domElement);
            
            // Add lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight1 = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight1.position.set(1, 1, 1);
            scene.add(directionalLight1);
            
            const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.4);
            directionalLight2.position.set(-1, -1, -1);
            scene.add(directionalLight2);
            
            // Add grid helper
            const gridHelper = new THREE.GridHelper(1000, 50, 0xcccccc, 0xeeeeee);
            scene.add(gridHelper);
            
            // Add axes helper
            const axesHelper = new THREE.AxesHelper(100);
            scene.add(axesHelper);
            
            // Add controls
            console.log('THREE object:', THREE);
            console.log('THREE.OrbitControls:', THREE.OrbitControls);
            
            try {
                if (THREE.OrbitControls) {
                    controls = new THREE.OrbitControls(camera, renderer.domElement);
                    console.log('Controls object created:', controls);
                    controls.enableDamping = true;
                    controls.dampingFactor = 0.05;
                    controls.enableRotate = true;
                    controls.enableZoom = true;
                    controls.enablePan = true;
                    controls.minDistance = 10;
                    controls.maxDistance = 50000;
                    controls.mouseButtons = {
                        LEFT: THREE.MOUSE.ROTATE,
                        MIDDLE: THREE.MOUSE.DOLLY,
                        RIGHT: THREE.MOUSE.PAN
                    };
                    
                    // Test if controls are responding
                    controls.addEventListener('change', () => {
                        console.log('OrbitControls change event fired');
                    });
                    
                    controls.addEventListener('start', () => {
                        console.log('OrbitControls start event');
                    });
                    
                    controls.addEventListener('end', () => {
                        console.log('OrbitControls end event');
                    });
                    
                    console.log('OrbitControls initialized successfully');
                    console.log('Controls enabled:', {
                        rotate: controls.enableRotate,
                        zoom: controls.enableZoom,
                        pan: controls.enablePan,
                        domElement: controls.domElement
                    });
                } else {
                    console.error('THREE.OrbitControls is undefined!');
                }
            } catch (error) {
                console.error('Error initializing OrbitControls:', error);
            }
            
            // Test canvas events
            renderer.domElement.addEventListener('mousedown', (e) => {
                console.log('Canvas mousedown:', e.button);
            });
            
            // Use double-click for point selection so OrbitControls can work freely
            renderer.domElement.addEventListener('dblclick', onBuildingClick);
            
            // Handle window resize
            window.addEventListener('resize', onWindowResize, false);
            
            // Animation loop
            function animate() {
                requestAnimationFrame(animate);
                if (controls && controls.update) {
                    controls.update();
                }
                renderer.render(scene, camera);
            }
            animate();
            
            is3DViewerInitialized = true;
        }
        
        function onWindowResize() {
            if (!is3DViewerInitialized) return;
            
            const viewer = document.getElementById('building-viewer');
            const width = viewer.clientWidth;
            const height = viewer.clientHeight;
            
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
        }
        
        function onBuildingClick(event) {
            // Check if 3D viewer is initialized
            if (!is3DViewerInitialized || ifcMeshes.length === 0) {
                console.log('3D viewer not ready yet');
                return;
            }
            
            // Check if raycaster is initialized
            if (!raycaster || !mouse) {
                console.error('Raycaster not initialized');
                return;
            }
            
            // Don't add points if we already have 3
            const existingPointIndex = buildingPoints.findIndex(p => !p || Object.keys(p.building).length === 0);
            const nextIndex = existingPointIndex !== -1 ? existingPointIndex : buildingPoints.length;
            
            if (nextIndex >= 3) {
                alert('Maximum 3 points allowed. Please clear existing points if you want to select new ones.');
                return;
            }
            
            // Get canvas rect for proper coordinate calculation
            const rect = renderer.domElement.getBoundingClientRect();
            
            // Calculate mouse position in normalized device coordinates (-1 to +1)
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            // Update the raycaster
            raycaster.setFromCamera(mouse, camera);
            
            // Calculate intersections
            const intersects = raycaster.intersectObjects(ifcMeshes, false);
            
            if (intersects.length > 0) {
                const intersection = intersects[0];
                const point3D = intersection.point;
                
                // Convert from meters to millimeters (ifcopenshell.geom returns meters, but IFC uses mm)
                // This matches the behavior of the old 2D view
                const point = {
                    screen: {
                        x: event.clientX - rect.left,
                        y: event.clientY - rect.top
                    },
                    building: {
                        x: point3D.x * 1000,  // Convert meters to millimeters
                        y: point3D.y * 1000,  // Convert meters to millimeters
                        z: point3D.z * 1000   // Convert meters to millimeters
                    }
                };
                
                buildingPoints[nextIndex] = point;
                
                // Add a visual marker in 3D space (use original meter coordinates for 3D scene)
                addPointMarker(point3D, nextIndex);
                
                // Update UI
                updateUI();
                
                console.log(`Point ${nextIndex + 1} selected (mm):`, point.building.x.toFixed(3), point.building.y.toFixed(3), point.building.z.toFixed(3));
            } else {
                console.log('No intersection found. Please click on the building model.');
            }
        }
        
        function addPointMarker(position, index) {
            // Remove existing marker for this point if it exists
            const existingMarker = scene.children.find(child => 
                child.userData && child.userData.pointIndex === index
            );
            if (existingMarker) {
                scene.remove(existingMarker);
            }
            
            // Calculate marker size based on model bounds (0.5% of largest dimension)
            const modelSize = ifcBounds ? Math.max(...ifcBounds.dimensions) : 1000;
            const markerSize = modelSize * 0.005;
            
            // Create a sphere marker
            const geometry = new THREE.SphereGeometry(markerSize, 16, 16);
            const material = new THREE.MeshBasicMaterial({
                color: 0xff0000,
                transparent: true,
                opacity: 0.8
            });
            const marker = new THREE.Mesh(geometry, material);
            marker.position.copy(position);
            marker.userData.pointIndex = index;
            marker.userData.isMarker = true;
            
            // Add label
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 128;
            canvas.height = 64;
            context.fillStyle = '#ffffff';
            context.fillRect(0, 0, canvas.width, canvas.height);
            context.fillStyle = '#000000';
            context.font = 'Bold 32px Arial';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(`P${index + 1}`, canvas.width / 2, canvas.height / 2);
            
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMaterial);
            const labelSize = modelSize * 0.02;
            sprite.scale.set(labelSize, labelSize * 0.5, 1);
            sprite.position.copy(position);
            sprite.position.z += markerSize * 3;  // Offset above the marker
            sprite.userData.pointIndex = index;
            sprite.userData.isMarker = true;
            
            scene.add(marker);
            scene.add(sprite);
        }
        
        function onMapClick(e) {
            // Find next available slot or stop at 3
            const existingPointIndex = mapPoints.findIndex(p => !p || Object.keys(p.coordinates).length === 0);
            const nextIndex = existingPointIndex !== -1 ? existingPointIndex : mapPoints.length;
            
            if (nextIndex >= 3) {
                alert('Maximum 3 points allowed. Please clear existing points if you want to select new ones.');
                return;
            }
            
            const latlng = e.latlng;
            
            // Convert to selected coordinate system
            const epsg = document.getElementById('epsg-select').value;
            
            let easting, northing;
            
            // Define proj4 coordinate systems
            if (typeof proj4 !== 'undefined') {
                // Define EPSG:2056 (Swiss CH1903+ / LV95) - Official definition
                // Using the correct parameters for CH1903+ coordinate system
                proj4.defs("EPSG:2056", "+proj=somerc +lat_0=46.95240555555556 +lon_0=7.439583333333333 +k_0=1 +x_0=2600000 +y_0=1200000 +ellps=bessel +towgs84=674.374,15.056,405.346,0,0,0,0 +units=m +no_defs");
                
                // Define other coordinate systems
                proj4.defs("EPSG:32632", "+proj=utm +zone=32 +datum=WGS84 +units=m +no_defs");
                proj4.defs("EPSG:32643", "+proj=utm +zone=43 +datum=WGS84 +units=m +no_defs");
                proj4.defs("EPSG:3857", "+proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +wgs84 +no_defs");
            }
            
            if (epsg === '2056') {
                // Use proj4js for accurate transformation
                if (typeof proj4 !== 'undefined') {
                    try {
                        // proj4 expects [longitude, latitude] order and returns [x, y]
                        const coords = proj4('EPSG:4326', 'EPSG:2056', [latlng.lng, latlng.lat]);
                        easting = coords[0];
                        northing = coords[1];
                        console.log('EPSG:2056 transformation:', latlng.lat, latlng.lng, '->', easting, northing);
                    } catch (error) {
                        console.error('Proj4 transformation error:', error);
                        alert('Error transforming coordinates: ' + error.message);
                        return;
                    }
                } else {
                    // Fallback to simple approximation if proj4 is not loaded
                    alert('Coordinate transformation library not loaded. Please refresh the page.');
                    return;
                }
                
            } else if (epsg === '21781') {
                // CH1903 / LV03 coordinate system for Switzerland (legacy)
                const lat = latlng.lat;
                const lng = latlng.lng;
                
                // Approximate transformation to CH1903 / LV03
                // Reference point: Bern (46.95°N, 7.44°E) ≈ (600000, 200000)
                const lat0 = 46.95;
                const lng0 = 7.44;
                const e0 = 600000;
                const n0 = 200000;
                
                const dlat = lat - lat0;
                const dlng = lng - lng0;
                
                easting = e0 + dlng * 111320 * Math.cos(lat * Math.PI / 180);
                northing = n0 + dlat * 110540;
                
            } else if (epsg === '32632') {
                // UTM Zone 32N for Central Europe - use proj4js
                if (typeof proj4 !== 'undefined') {
                    const coords = proj4('EPSG:4326', 'EPSG:32632', [latlng.lng, latlng.lat]);
                    easting = coords[0];
                    northing = coords[1];
                } else {
                    // Fallback to manual calculation
                    const lat = latlng.lat;
                    const lng = latlng.lng;
                    
                    // UTM Zone 32N (central meridian 9°E) conversion
                    const k0 = 0.9996;
                    const a = 6378137; // WGS84 semi-major axis
                    const f = 1/298.257223563; // WGS84 flattening
                    const e = Math.sqrt(2*f - f*f); // eccentricity
                    
                    const latRad = lat * Math.PI / 180;
                    const lngRad = lng * Math.PI / 180;
                    const centralMeridian = 9 * Math.PI / 180; // UTM Zone 32N
                    
                    const deltaLng = lngRad - centralMeridian;
                    
                    const N = a / Math.sqrt(1 - e*e * Math.sin(latRad)*Math.sin(latRad));
                    const T = Math.tan(latRad) * Math.tan(latRad);
                    const C = (e*e/(1-e*e)) * Math.cos(latRad) * Math.cos(latRad);
                    const A = Math.cos(latRad) * deltaLng;
                    
                    const M = a * ((1 - e*e/4 - 3*e*e*e*e/64 - 5*Math.pow(e,6)/256) * latRad
                               - (3*e*e/8 + 3*e*e*e*e/32 + 45*Math.pow(e,6)/1024) * Math.sin(2*latRad)
                               + (15*e*e*e*e/256 + 45*Math.pow(e,6)/1024) * Math.sin(4*latRad)
                               - (35*Math.pow(e,6)/3072) * Math.sin(6*latRad));
                    
                    easting = k0 * N * (A + (1-T+C)*A*A*A/6 + (5-18*T+T*T+72*C-58*(e*e/(1-e*e)))*Math.pow(A,5)/120) + 500000;
                    northing = k0 * (M + N*Math.tan(latRad)*(A*A/2 + (5-T+9*C+4*C*C)*Math.pow(A,4)/24 + (61-58*T+T*T+600*C-330*(e*e/(1-e*e)))*Math.pow(A,6)/720));
                    
                    // Ensure we're in the northern hemisphere
                    if (northing < 0) northing += 10000000;
                }
                
            } else if (epsg === '32643') {
                // UTM Zone 43N for Pakistan - use proj4js
                if (typeof proj4 !== 'undefined') {
                    const coords = proj4('EPSG:4326', 'EPSG:32643', [latlng.lng, latlng.lat]);
                    easting = coords[0];
                    northing = coords[1];
                } else {
                    // Fallback to manual calculation
                    const lat = latlng.lat;
                    const lng = latlng.lng;
                    
                    // UTM Zone 43N (central meridian 75°E) conversion
                    const k0 = 0.9996;
                    const a = 6378137; // WGS84 semi-major axis
                    const f = 1/298.257223563; // WGS84 flattening
                    const e = Math.sqrt(2*f - f*f); // eccentricity
                    
                    const latRad = lat * Math.PI / 180;
                    const lngRad = lng * Math.PI / 180;
                    const centralMeridian = 75 * Math.PI / 180; // UTM Zone 43N
                    
                    const deltaLng = lngRad - centralMeridian;
                    
                    const N = a / Math.sqrt(1 - e*e * Math.sin(latRad)*Math.sin(latRad));
                    const T = Math.tan(latRad) * Math.tan(latRad);
                    const C = (e*e/(1-e*e)) * Math.cos(latRad) * Math.cos(latRad);
                    const A = Math.cos(latRad) * deltaLng;
                    
                    const M = a * ((1 - e*e/4 - 3*e*e*e*e/64 - 5*Math.pow(e,6)/256) * latRad
                               - (3*e*e/8 + 3*e*e*e*e/32 + 45*Math.pow(e,6)/1024) * Math.sin(2*latRad)
                               + (15*e*e*e*e/256 + 45*Math.pow(e,6)/1024) * Math.sin(4*latRad)
                               - (35*Math.pow(e,6)/3072) * Math.sin(6*latRad));
                    
                    easting = k0 * N * (A + (1-T+C)*A*A*A/6 + (5-18*T+T*T+72*C-58*(e*e/(1-e*e)))*Math.pow(A,5)/120) + 500000;
                    northing = k0 * (M + N*Math.tan(latRad)*(A*A/2 + (5-T+9*C+4*C*C)*A*A*A*A/24 + (61-58*T+T*T+600*C-330*(e*e/(1-e*e)))*Math.pow(A,6)/720));
                }
                
            } else {
                // Simplified conversion for other systems
                easting = latlng.lng * 111320;
                northing = latlng.lat * 110540;
            }
            
            const elevation = 400; // Default elevation for Zurich area (Switzerland)
            
            // Validate map point distances to ensure reasonable building scale
            if (mapPoints.length > 0) {
                const firstPoint = mapPoints[0];
                const distance = calculateDistance(firstPoint.latlng.lat, firstPoint.latlng.lng, latlng.lat, latlng.lng);
                
                // If distance is more than 1km, warn user
                if (distance > 1000) {
                    if (!confirm(`Warning: This point is ${(distance/1000).toFixed(2)}km away from the first point. This might make your building appear very large. Continue anyway?`)) {
                        return;
                    }
                }
            }
            
            const point = {
                latlng: latlng,
                coordinates: {
                    easting: easting,
                    northing: northing,
                    elevation: elevation
                },
                epsg: epsg
            };
            
            mapPoints[nextIndex] = point;
            
            // Remove existing marker for this point if it exists
            map.eachLayer(function(layer) {
                if (layer instanceof L.Marker && layer.options.pointIndex === nextIndex) {
                    map.removeLayer(layer);
                }
            });
            
            // Add marker to map
            const marker = L.marker([latlng.lat, latlng.lng], { pointIndex: nextIndex })
                .addTo(map)
                .bindPopup(`Point ${nextIndex + 1}<br>Lat: ${latlng.lat.toFixed(6)}<br>Lng: ${latlng.lng.toFixed(6)}<br>UTM: ${easting.toFixed(2)}, ${northing.toFixed(2)}`);
            
            updateUI();
            updateManualEntryUI();
        }
        
        // Function to add point manually by entering lat/lng
        function addManualPoint() {
            const existingPointIndex = mapPoints.findIndex(p => !p || Object.keys(p.coordinates).length === 0);
            const nextIndex = existingPointIndex !== -1 ? existingPointIndex : mapPoints.length;
            
            if (nextIndex >= 3) {
                alert('Maximum 3 points allowed. Please clear existing points if you want to select new ones.');
                return;
            }
            
            const latInput = document.getElementById('manual-lat');
            const lngInput = document.getElementById('manual-lng');
            
            const lat = parseFloat(latInput.value);
            const lng = parseFloat(lngInput.value);
            
            // Validate inputs
            if (isNaN(lat) || isNaN(lng)) {
                alert('Please enter valid latitude and longitude values.');
                return;
            }
            
            if (lat < -90 || lat > 90) {
                alert('Latitude must be between -90 and 90 degrees.');
                return;
            }
            
            if (lng < -180 || lng > 180) {
                alert('Longitude must be between -180 and 180 degrees.');
                return;
            }
            
            // Create a latlng object and process it like a map click
            const latlng = { lat: lat, lng: lng };
            
            // Convert to selected coordinate system
            const epsg = document.getElementById('epsg-select').value;
            let easting, northing;
            
            // Define proj4 coordinate systems
            if (typeof proj4 !== 'undefined') {
                proj4.defs("EPSG:2056", "+proj=somerc +lat_0=46.95240555555556 +lon_0=7.439583333333333 +k_0=1 +x_0=2600000 +y_0=1200000 +ellps=bessel +towgs84=674.374,15.056,405.346,0,0,0,0 +units=m +no_defs");
            }
            
            if (epsg === '2056') {
                if (typeof proj4 !== 'undefined') {
                    try {
                        const coords = proj4('EPSG:4326', 'EPSG:2056', [lng, lat]);
                        easting = coords[0];
                        northing = coords[1];
                        console.log('Manual EPSG:2056 transformation:', lat, lng, '->', easting, northing);
                    } catch (error) {
                        console.error('Proj4 transformation error:', error);
                        alert('Error transforming coordinates: ' + error.message);
                        return;
                    }
                } else {
                    alert('Coordinate transformation library not loaded. Please refresh the page.');
                    return;
                }
            } else {
                // Fallback for other coordinate systems
                easting = lng * 111320;
                northing = lat * 110540;
            }
            
            const elevation = 400; // Default elevation for Zurich area (Switzerland)
            
            // Validate distance from first point
            if (mapPoints.length > 0) {
                const firstPoint = mapPoints[0];
                const distance = calculateDistance(firstPoint.latlng.lat, firstPoint.latlng.lng, lat, lng);
                
                if (distance > 1000) {
                    if (!confirm(`Warning: This point is ${(distance/1000).toFixed(2)}km away from the first point. This might make your building appear very large. Continue anyway?`)) {
                        return;
                    }
                }
            }
            
            const point = {
                latlng: latlng,
                coordinates: {
                    easting: easting,
                    northing: northing,
                    elevation: elevation
                },
                epsg: epsg
            };
            
            mapPoints[nextIndex] = point;
            
            // Remove existing marker for this point if it exists
            map.eachLayer(function(layer) {
                if (layer instanceof L.Marker && layer.options.pointIndex === nextIndex) {
                    map.removeLayer(layer);
                }
            });
            
            // Add marker to map
            const marker = L.marker([lat, lng], { pointIndex: nextIndex })
                .addTo(map)
                .bindPopup(`Point ${nextIndex + 1}<br>Lat: ${lat.toFixed(6)}<br>Lng: ${lng.toFixed(6)}<br>E: ${easting.toFixed(2)}, N: ${northing.toFixed(2)}`);
            
            // Pan map to the new marker
            map.setView([lat, lng], map.getZoom());
            
            // Clear input fields
            latInput.value = '';
            lngInput.value = '';
            
            updateUI();
            updateManualEntryUI();
        }
        
        // Update manual entry UI to show current point number
        function updateManualEntryUI() {
            const pointNumber = mapPoints.length + 1;
            const pointNumberSpan = document.getElementById('current-point-number');
            if (pointNumberSpan) {
                pointNumberSpan.textContent = pointNumber;
            }
            
            // Disable manual entry if we have 3 points already
            const manualLat = document.getElementById('manual-lat');
            const manualLng = document.getElementById('manual-lng');
            if (mapPoints.length >= 3) {
                if (manualLat) manualLat.disabled = true;
                if (manualLng) manualLng.disabled = true;
            } else {
                if (manualLat) manualLat.disabled = false;
                if (manualLng) manualLng.disabled = false;
            }
        }
        
        // Helper function to calculate distance between two lat/lng points
        function calculateDistance(lat1, lng1, lat2, lng2) {
            const R = 6371000; // Earth's radius in meters
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLng = (lng2 - lng1) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                      Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                      Math.sin(dLng/2) * Math.sin(dLng/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }
        
        // Unit conversion functions for building coordinates
        function convertToMm(value, fromUnit) {
            switch(fromUnit) {
                case 'mm': return value;
                case 'm': return value * 1000;
                case 'in': return value * 25.4;
                case 'ft': return value * 304.8;
                default: return value;
            }
        }
        
        function convertFromMm(value, toUnit) {
            switch(toUnit) {
                case 'mm': return value;
                case 'm': return value / 1000;
                case 'in': return value / 25.4;
                case 'ft': return value / 304.8;
                default: return value;
            }
        }
        
        function convertBuildingUnits() {
            const newUnit = document.getElementById('building-unit').value;
            
            // Convert all existing values to the new unit
            for (let i = 0; i < 3; i++) {
                const xInput = document.querySelector(`.building-coord[data-point="${i}"][data-axis="x"]`);
                const yInput = document.querySelector(`.building-coord[data-point="${i}"][data-axis="y"]`);
                const zInput = document.querySelector(`.building-coord[data-point="${i}"][data-axis="z"]`);
                
                if (xInput && xInput.value && buildingPoints[i]) {
                    const xMm = buildingPoints[i].building.x; // Always stored in mm
                    xInput.value = convertFromMm(xMm, newUnit).toFixed(6);
                }
                
                if (yInput && yInput.value && buildingPoints[i]) {
                    const yMm = buildingPoints[i].building.y;
                    yInput.value = convertFromMm(yMm, newUnit).toFixed(6);
                }
                
                if (zInput && zInput.value && buildingPoints[i]) {
                    const zMm = buildingPoints[i].building.z;
                    zInput.value = convertFromMm(zMm, newUnit).toFixed(6);
                }
            }
        }
        
        // Handle manual building coordinate entry from table
        function handleBuildingCoordInput(event) {
            const input = event.target;
            const pointIndex = parseInt(input.dataset.point);
            const axis = input.dataset.axis;
            const value = parseFloat(input.value);
            
            // Initialize or update the building point
            if (!buildingPoints[pointIndex]) {
                buildingPoints[pointIndex] = {
                    screen: {x: 0, y: 0},
                    building: {x: 0, y: 0, z: 0}
                };
            }
            
            // Convert input value to mm for internal storage
            if (!isNaN(value)) {
                const currentUnit = document.getElementById('building-unit').value;
                const valueInMm = convertToMm(value, currentUnit);
                buildingPoints[pointIndex].building[axis] = valueInMm;
            }
            
            // Check if all three coordinates are filled for this point
            const xInput = document.querySelector(`.building-coord[data-point="${pointIndex}"][data-axis="x"]`);
            const yInput = document.querySelector(`.building-coord[data-point="${pointIndex}"][data-axis="y"]`);
            const zInput = document.querySelector(`.building-coord[data-point="${pointIndex}"][data-axis="z"]`);
            
            const x = parseFloat(xInput.value);
            const y = parseFloat(yInput.value);
            const z = parseFloat(zInput.value);
            
            if (!isNaN(x) && !isNaN(y) && !isNaN(z)) {
                // Update the building point with all coordinates
                buildingPoints[pointIndex].building = {x: x, y: y, z: z};
                
                // Calculate screen position for visual marker
                const buildingDiv = document.querySelector('.viewer-container div[style*="border: 2px dashed"]');
                if (buildingDiv && ifcBounds) {
                    const rect = buildingDiv.getBoundingClientRect();
                    
                    // Convert building coordinates back to screen coordinates
                    const relX = (x - ifcBounds.min[0]) / ifcBounds.dimensions[0];
                    const relY = (y - ifcBounds.min[1]) / ifcBounds.dimensions[1];
                    
                    const screenX = relX * rect.width;
                    const screenY = (1 - relY) * rect.height; // Flip Y axis
                    
                    buildingPoints[pointIndex].screen = {x: screenX, y: screenY};
                    
                    // Remove existing marker for this point
                    const existingMarker = buildingDiv.querySelector(`.building-point[data-point="${pointIndex}"]`);
                    if (existingMarker) {
                        existingMarker.remove();
                    }
                    
                    // Add visual marker
                    const marker = document.createElement('div');
                    marker.className = 'point-marker building-point';
                    marker.setAttribute('data-point', pointIndex);
                    marker.style.left = screenX + 'px';
                    marker.style.top = screenY + 'px';
                    marker.title = `P${pointIndex + 1}: (${x.toFixed(6)}, ${y.toFixed(6)}, ${z.toFixed(6)})`;
                    buildingDiv.appendChild(marker);
                }
            }
            
            // Update UI without reformatting the table
            updateUIWithoutTableUpdate();
        }
        
        // Handle manual map coordinate entry from table
        function handleMapCoordInput(event) {
            const input = event.target;
            const pointIndex = parseInt(input.dataset.point);
            const axis = input.dataset.axis;
            const value = parseFloat(input.value);
            
            // Initialize or update the map point
            if (!mapPoints[pointIndex]) {
                mapPoints[pointIndex] = {
                    latlng: {lat: 0, lng: 0},
                    coordinates: {easting: 0, northing: 0, elevation: 0},
                    epsg: document.getElementById('epsg-select').value
                };
            }
            
            // Always update the axis value
            if (!isNaN(value)) {
                mapPoints[pointIndex].coordinates[axis] = value;
            }
            
            // Check if easting and northing are filled for this point
            const eastingInput = document.querySelector(`.map-coord[data-point="${pointIndex}"][data-axis="easting"]`);
            const northingInput = document.querySelector(`.map-coord[data-point="${pointIndex}"][data-axis="northing"]`);
            const elevationInput = document.querySelector(`.map-coord[data-point="${pointIndex}"][data-axis="elevation"]`);
            
            const easting = parseFloat(eastingInput.value);
            const northing = parseFloat(northingInput.value);
            const elevation = parseFloat(elevationInput.value) || 400;
            
            if (!isNaN(easting) && !isNaN(northing)) {
                // Convert from projected coordinates back to lat/lng
                const epsg = document.getElementById('epsg-select').value;
                let lat, lng;
                
                if (typeof proj4 !== 'undefined') {
                    try {
                        // Ensure EPSG:2056 is defined
                        proj4.defs("EPSG:2056", "+proj=somerc +lat_0=46.95240555555556 +lon_0=7.439583333333333 +k_0=1 +x_0=2600000 +y_0=1200000 +ellps=bessel +towgs84=674.374,15.056,405.346,0,0,0,0 +units=m +no_defs");
                        
                        // Transform from projected to WGS84
                        const coords = proj4(`EPSG:${epsg}`, 'EPSG:4326', [easting, northing]);
                        lng = coords[0];
                        lat = coords[1];
                    } catch (error) {
                        console.error('Reverse transformation error:', error);
                        updateUIWithoutTableUpdate();
                        return;
                    }
                } else {
                    // Fallback approximation
                    lng = easting / 111320;
                    lat = northing / 110540;
                }
                
                // Update the map point
                mapPoints[pointIndex] = {
                    latlng: {lat: lat, lng: lng},
                    coordinates: {easting: easting, northing: northing, elevation: elevation},
                    epsg: epsg
                };
                
                // Update lat/lng display in table
                const latlngCell = document.querySelectorAll('.latlng-display')[pointIndex];
                if (latlngCell) {
                    latlngCell.textContent = `${lat.toFixed(6)}°N, ${lng.toFixed(6)}°E`;
                }
                
                // Remove existing marker for this point if it exists
                map.eachLayer(function(layer) {
                    if (layer instanceof L.Marker && layer.options.pointIndex === pointIndex) {
                        map.removeLayer(layer);
                    }
                });
                
                // Add marker to map
                const marker = L.marker([lat, lng], { pointIndex: pointIndex })
                    .addTo(map)
                    .bindPopup(`Point ${pointIndex + 1}<br>Lat: ${lat.toFixed(6)}<br>Lng: ${lng.toFixed(6)}<br>E: ${easting.toFixed(2)}, N: ${northing.toFixed(2)}`);
                
                // Pan map to show the marker
                map.setView([lat, lng], map.getZoom());
            }
            
            updateUIWithoutTableUpdate();
        }
        
        function nextStep() {
            if (buildingPoints.length !== 3) {
                alert('Please select exactly 3 points on the building first.');
                return;
            }
            
            currentStep = 2;
            updateUI();
            
            // Update step indicators
            document.getElementById('step1').classList.add('completed');
            document.getElementById('step1').classList.remove('active');
            document.getElementById('step2').classList.add('active');
            
            // Update panel titles
            document.getElementById('left-title').textContent = 'Selected Building Points';
            document.getElementById('right-title').textContent = 'Step 2: Select Geographic Coordinates';
            
            // Show map instruction
            document.getElementById('map-instruction').style.display = 'block';
            
            // Show manual entry form
            document.getElementById('manual-entry').style.display = 'block';
            updateManualEntryUI();
            
            // Update instruction
            document.getElementById('instruction').innerHTML = `
                <strong>Building points selected: ${buildingPoints.length}</strong><br>
                Now click on the map to set geographic coordinates for each point.<br>
                <span><strong>⚠️ Important:</strong> Click points close together for a normal-sized building.</span><br>
                Click in the same order as you selected the building points.
            `;
        }
        
        function clearBuildingPoints() {
            buildingPoints = [];
            
            // Remove 3D markers from scene
            if (scene) {
                const markersToRemove = scene.children.filter(child => 
                    child.userData && child.userData.isMarker
                );
                markersToRemove.forEach(marker => scene.remove(marker));
            }
            
            // Clear building coordinate inputs in table
            document.querySelectorAll('.building-coord').forEach(input => {
                input.value = '';
            });
            
            updateUI();
        }
        
        function clearMapPoints() {
            mapPoints = [];
            map.eachLayer(function(layer) {
                if (layer instanceof L.Marker && layer.getLatLng().lat !== 33.6844) {
                    map.removeLayer(layer);
                }
            });
            // Clear manual input fields
            const manualLat = document.getElementById('manual-lat');
            const manualLng = document.getElementById('manual-lng');
            if (manualLat) manualLat.value = '';
            if (manualLng) manualLng.value = '';
            
            // Clear map coordinate inputs in table
            document.querySelectorAll('.map-coord').forEach(input => {
                input.value = '';
            });
            
            // Clear lat/lng display
            document.querySelectorAll('.latlng-display').forEach(cell => {
                cell.textContent = '-';
            });
            
            updateUI();
            updateManualEntryUI();
        }
        
        function updateUI() {
            // Update button states
            document.getElementById('clear-map').disabled = mapPoints.length === 0;
            
            // Update coordinates table first
            updateCoordinatesTable();
            
            // Check if all 3 points are completely filled in the table
            let allPointsFilled = true;
            for (let i = 0; i < 3; i++) {
                const xInput = document.querySelector(`.building-coord[data-point="${i}"][data-axis="x"]`);
                const yInput = document.querySelector(`.building-coord[data-point="${i}"][data-axis="y"]`);
                const zInput = document.querySelector(`.building-coord[data-point="${i}"][data-axis="z"]`);
                const eastingInput = document.querySelector(`.map-coord[data-point="${i}"][data-axis="easting"]`);
                const northingInput = document.querySelector(`.map-coord[data-point="${i}"][data-axis="northing"]`);
                const elevationInput = document.querySelector(`.map-coord[data-point="${i}"][data-axis="elevation"]`);
                
                if (!xInput?.value || !yInput?.value || !zInput?.value || 
                    !eastingInput?.value || !northingInput?.value || !elevationInput?.value) {
                    allPointsFilled = false;
                    break;
                }
            }
            
            // Enable generate config button only when all table fields are filled
            const generateConfigBtn = document.getElementById('generate-config-bottom');
            if (generateConfigBtn) {
                generateConfigBtn.disabled = !allPointsFilled;
            }
        }
        
        // Update UI without reformatting table values (for manual input)
        function updateUIWithoutTableUpdate() {
            // Update button states
            document.getElementById('clear-map').disabled = mapPoints.length === 0;
            
            // Check if all 3 points are completely filled in the table
            let allPointsFilled = true;
            for (let i = 0; i < 3; i++) {
                const xInput = document.querySelector(`.building-coord[data-point="${i}"][data-axis="x"]`);
                const yInput = document.querySelector(`.building-coord[data-point="${i}"][data-axis="y"]`);
                const zInput = document.querySelector(`.building-coord[data-point="${i}"][data-axis="z"]`);
                const eastingInput = document.querySelector(`.map-coord[data-point="${i}"][data-axis="easting"]`);
                const northingInput = document.querySelector(`.map-coord[data-point="${i}"][data-axis="northing"]`);
                const elevationInput = document.querySelector(`.map-coord[data-point="${i}"][data-axis="elevation"]`);
                
                if (!xInput?.value || !yInput?.value || !zInput?.value || 
                    !eastingInput?.value || !northingInput?.value || !elevationInput?.value) {
                    allPointsFilled = false;
                    break;
                }
            }
            
            // Enable generate config button only when all table fields are filled
            const generateConfigBtn = document.getElementById('generate-config-bottom');
            if (generateConfigBtn) {
                generateConfigBtn.disabled = !allPointsFilled;
            }
        }
        
        function updateCoordinatesTable() {
            // Update the input fields based on the clicked points
            for (let i = 0; i < 3; i++) {
                const buildingPoint = buildingPoints[i];
                const mapPoint = mapPoints[i];
                
                // Update building coordinates
                if (buildingPoint) {
                    const xInput = document.querySelector(`.building-coord[data-point="${i}"][data-axis="x"]`);
                    const yInput = document.querySelector(`.building-coord[data-point="${i}"][data-axis="y"]`);
                    const zInput = document.querySelector(`.building-coord[data-point="${i}"][data-axis="z"]`);
                    
                    const currentUnit = document.getElementById('building-unit').value;
                    
                    if (xInput) xInput.value = convertFromMm(buildingPoint.building.x, currentUnit).toFixed(6);
                    if (yInput) yInput.value = convertFromMm(buildingPoint.building.y, currentUnit).toFixed(6);
                    if (zInput) zInput.value = convertFromMm(buildingPoint.building.z, currentUnit).toFixed(6);
                }
                
                // Update map coordinates
                if (mapPoint) {
                    const eastingInput = document.querySelector(`.map-coord[data-point="${i}"][data-axis="easting"]`);
                    const northingInput = document.querySelector(`.map-coord[data-point="${i}"][data-axis="northing"]`);
                    const elevationInput = document.querySelector(`.map-coord[data-point="${i}"][data-axis="elevation"]`);
                    const latlngCell = document.querySelectorAll('.latlng-display')[i];
                    
                    if (eastingInput) eastingInput.value = mapPoint.coordinates.easting.toFixed(6);
                    if (northingInput) northingInput.value = mapPoint.coordinates.northing.toFixed(6);
                    if (elevationInput) elevationInput.value = mapPoint.coordinates.elevation.toFixed(6);
                    if (latlngCell) latlngCell.textContent = `${mapPoint.latlng.lat.toFixed(6)}°N, ${mapPoint.latlng.lng.toFixed(6)}°E`;
                }
            }
        }
        
        function generateConfig() {
            if (buildingPoints.length !== 3 || mapPoints.length !== 3) {
                alert('Please ensure you have exactly 3 building points and 3 map points.');
                return;
            }
            
            currentStep = 3;
            
            // Update step indicators
            document.getElementById('step2').classList.add('completed');
            document.getElementById('step2').classList.remove('active');
            document.getElementById('step3').classList.add('active');
            
            const epsg = document.getElementById('epsg-select').value;
            
            // Show configuration for reference
            let configText = `
<h4>Generated Configuration:</h4>
<p><strong>EPSG Code:</strong> ${epsg}</p>
<p><strong>Number of Control Points:</strong> ${buildingPoints.length}</p>
<p><strong>Status:</strong> <span style="color: green;">Ready to submit automatically!</span></p>

<div style="margin: 20px 0;">
    <button onclick="autoSubmitToGeoreferencing()" class="btn btn-success" style="font-size: 16px; padding: 12px 24px;">
        Automatically Submit to Georeferencing
    </button>
    <button onclick="showManualInstructions()" class="btn" style="margin-left: 10px;">
        Show Manual Instructions
    </button>
</div>

<div id="manual-instructions" style="display: none;">
<h5>Manual Entry (if needed):</h5>
<h6>Local IFC coordinates (meters):</h6>
<pre>`;
            
            buildingPoints.forEach((point, i) => {
                configText += `P${i + 1} = (${point.building.x.toFixed(3)}, ${point.building.y.toFixed(3)}, ${point.building.z.toFixed(3)})\n`;
            });
            
            configText += `</pre>

<h6>Target coordinates in EPSG:${epsg}:</h6>
<pre>`;
            
            mapPoints.forEach((point, i) => {
                configText += `P${i + 1}' = (${point.coordinates.easting.toFixed(2)}, ${point.coordinates.northing.toFixed(2)}, ${point.coordinates.elevation.toFixed(1)})\n`;
            });
            
            configText += `</pre>
</div>`;
            
            document.getElementById('config-output').innerHTML = configText;
            document.getElementById('final-config').style.display = 'block';
            
            // Scroll to bottom
            document.getElementById('final-config').scrollIntoView({ behavior: 'smooth' });
        }
        
        function showManualInstructions() {
            document.getElementById('manual-instructions').style.display = 'block';
        }
        
        function autoSubmitToGeoreferencing() {
            // Get the current filename from URL or prompt user
            let filename = getSelectedFilename();
            
            if (!filename) {
                filename = prompt('Enter your IFC filename (e.g., building.ifc):');
                if (!filename) {
                    alert('Filename is required to proceed.');
                    return;
                }
            }

            const epsg = document.getElementById('epsg-select').value;

            // Show loading message
            const loadingDiv = document.createElement('div');
            loadingDiv.innerHTML = `
                <div style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
                           background: rgba(0,0,0,0.8); display: flex; align-items: center; 
                           justify-content: center; z-index: 10000; color: white;">
                    <div style="text-align: center;">
                        <h2>🚀 Submitting to Georeferencing...</h2>
                        <p>Automatically entering your coordinates and processing...</p>
                        <div style="margin: 20px 0;">⏳ Please wait...</div>
                    </div>
                </div>
            `;
            document.body.appendChild(loadingDiv);

            // Send data to the backend
            fetch('/auto_georeference', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    filename: filename,
                    buildingPoints: buildingPoints,
                    mapPoints: mapPoints,
                    epsgCode: epsg
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    // Go directly to the final form
                    window.location.href = data.redirect_url;
                } else {
                    alert('Error: ' + data.error);
                    document.body.removeChild(loadingDiv);
                }
            })
            .catch(error => {
                console.error('Error:', error);
                alert('Error submitting points: ' + error);
                document.body.removeChild(loadingDiv);
            });
            
            form.submit();
        }
        
        function getSelectedFilename() {
            // Try to get filename from URL parameters or previous selection
            const urlParams = new URLSearchParams(window.location.search);
            return urlParams.get('filename') || sessionStorage.getItem('selectedFilename');
        }
        
        function testTransformation() {
            // Test EPSG:2056 transformation with a known point
            // Zurich center: 47.3769°N, 8.5417°E should be approximately E=2683000, N=1248000
            const testLat = 47.3769;
            const testLng = 8.5417;
            
            if (typeof proj4 !== 'undefined') {
                proj4.defs("EPSG:2056", "+proj=somerc +lat_0=46.95240555555556 +lon_0=7.439583333333333 +k_0=1 +x_0=2600000 +y_0=1200000 +ellps=bessel +towgs84=674.374,15.056,405.346,0,0,0,0 +units=m +no_defs");
                const coords = proj4('EPSG:4326', 'EPSG:2056', [testLng, testLat]);
                console.log('Test transformation for Zurich:');
                console.log('Input: Lat=' + testLat + ', Lng=' + testLng);
                console.log('Output: E=' + coords[0].toFixed(2) + ', N=' + coords[1].toFixed(2));
                console.log('Expected approximately: E=2683000, N=1248000');
                alert('Test transformation:\nInput: ' + testLat + '°N, ' + testLng + '°E\nOutput: E=' + coords[0].toFixed(2) + ', N=' + coords[1].toFixed(2) + '\n\nCheck console for details.');
            } else {
                alert('Proj4js not loaded!');
            }
        }
    </script>
</body>
</html>
